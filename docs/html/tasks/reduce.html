<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tasks.reduce API documentation</title>
<meta name="description" content="In reduced problems, we use two modes, which
are quoted in two different directions. Some
of the tasks can only be transferred to one mod.
The …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tasks.reduce</code></h1>
</header>
<section id="section-intro">
<p>In reduced problems, we use two modes, which
are quoted in two different directions. Some
of the tasks can only be transferred to one mod.
The contextual task is transferred to two modes at once.
The network must ignore the wrong mod.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
In reduced problems, we use two modes, which
are quoted in two different directions. Some
of the tasks can only be transferred to one mod.
The contextual task is transferred to two modes at once.
The network must ignore the wrong mod.
&#34;&#34;&#34;
from typing import Optional, Tuple, Union

import numpy as np


class DefaultParams:
    &#34;&#34;&#34;
    This method is used to create a new Params class .
    &#34;&#34;&#34;

    def __init__(self, task: str):
        &#34;&#34;&#34;
        Initialize the task.

        Args:
            task (str): [Name of task]
        &#34;&#34;&#34;
        self._task = task

    def generate_params(self):
        &#34;&#34;&#34;
        Generate parameters for the task .

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        if self._task == &#34;DMTask&#34;:
            return dict([(&#34;dt&#34;, 1e-3), (&#34;delay&#34;, 0.3), (&#34;trial_time&#34;, 0.75)])
        elif self._task == &#34;RomoTask&#34;:
            return dict([(&#34;dt&#34;, 1e-3), (&#34;delay&#34;, 0.3), (&#34;trial_time&#34;, 0.25)])
        elif self._task == &#34;CtxDMTask&#34;:
            return dict([(&#34;dt&#34;, 1e-3), (&#34;delay&#34;, 0.3), (&#34;trial_time&#34;, 0.75)])
        elif self._task == &#34;DMTaskRandomMod&#34;:
            return dict(
                [(&#34;dt&#34;, 1e-3), (&#34;delay&#34;, 0.3), (&#34;trial_time&#34;, 0.75), (&#34;n_mods&#34;, 2)]
            )
        elif self._task == &#34;RomoTaskRandomMod&#34;:
            return dict(
                [(&#34;dt&#34;, 1e-3), (&#34;delay&#34;, 0.3), (&#34;trial_time&#34;, 0.25), (&#34;n_mods&#34;, 2)]
            )
        else:
            raise ValueError(f&#34;Task: {self._task} is not supported&#34;)


class ReduceTaskCognitive:
    &#34;&#34;&#34;
    Class method for ReduceTask .
    &#34;&#34;&#34;

    def __init__(self, params: dict, batch_size: int, mode: str) -&gt; None:
        &#34;&#34;&#34;
        Initialize the instance .

        Args:
            params (dict): [description]
            batch_size (int): [description]
            mode (str): [description]
        &#34;&#34;&#34;
        self._params = params
        self._batch_size = batch_size
        self._ob_size = 0
        self._act_size = 0
        self._mode = mode

    def one_dataset(self) -&gt; Tuple[np.ndarray, np.ndarray]:
        &#34;&#34;&#34;
        Return a tuple containing one - dimensional dataset .

        Returns:
            Tuple[np.ndarray, np.ndarray]: [description]
        &#34;&#34;&#34;
        return Tuple[np.ndarray, np.ndarray]

    def dataset(self, n_trials: int = 1):
        multy_inputs, multy_outputs = self.one_dataset()
        for _ in range(n_trials - 1):
            inputs, outputs = self.one_dataset()
            multy_inputs = np.concatenate((multy_inputs, inputs), axis=0)
            multy_outputs = np.concatenate((multy_outputs, outputs), axis=0)
        return multy_inputs, multy_outputs

    @property
    def feature_and_act_size(self) -&gt; Tuple[int, int]:
        &#34;&#34;&#34;
        Returns the feature and action size .

        Returns:
            Tuple[int, int]: [feature size, act_size (output size)]
        &#34;&#34;&#34;
        return self._ob_size, self._act_size

    @feature_and_act_size.setter
    def feature_and_act_size(self, values: Tuple[int, int]):
        &#34;&#34;&#34;
        Set the feature and action size .

        Args:
            values (Tuple[int, int]): [feature size, act_size (output size)]
        &#34;&#34;&#34;
        self._ob_size, self._act_size = values

    @property
    def params(self) -&gt; dict:
        &#34;&#34;&#34;
        A dictionary with the current parameters .

        Returns:
            dict: [description]
        &#34;&#34;&#34;
        return self._params

    @params.setter
    def params(self, new_params: dict):
        &#34;&#34;&#34;
        Set the new parameters of this query.

        Args:
            new_params (dict): [description]
        &#34;&#34;&#34;
        self._params = new_params

    @property
    def batch_size(self) -&gt; int:
        &#34;&#34;&#34;
        Number of batches that have been created .

        Returns:
            int: [description]
        &#34;&#34;&#34;
        return self._batch_size

    @batch_size.setter
    def batch_size(self, new_batch_size: int):
        &#34;&#34;&#34;
        Set the batch_size of the batch .

        Args:
            new_batch_size (int): [description]
        &#34;&#34;&#34;
        self._batch_size = new_batch_size


class DMTask(ReduceTaskCognitive):
    &#34;&#34;&#34;
    Construct a DMTask class for DMTask .

    Args:
        ReduceTaskCognitive ([type]): [description]

    Returns:
        [type]: [description]
    &#34;&#34;&#34;

    threshold = 0.5

    def __init__(
        self, params: Optional[dict] = None, batch_size: int = 1, mode: str = &#34;random&#34;
    ) -&gt; None:
        &#34;&#34;&#34;
        Initialize the model .

        Args:
            params (Optional[dict], optional): [description]. Defaults to None.
            batch_size (int, optional): [description]. Defaults to 1.
            mode (str, optional): [description]. Defaults to &#34;random&#34;.
        &#34;&#34;&#34;
        if params is None:
            params = DefaultParams(&#34;DMTask&#34;).generate_params()
        super().__init__(params, batch_size, mode)
        self._ob_size = 2
        self._act_size = 3

    def _one_dataset(self) -&gt; Tuple[np.ndarray, np.ndarray]:
        &#34;&#34;&#34;
        Returns a single dataset with inputs and target outputs .

        Returns:
            Tuple[np.ndarray, np.ndarray]: [inputs, outputs]
        &#34;&#34;&#34;
        dt = self._params[&#34;dt&#34;]
        trial_time = int(self._params[&#34;trial_time&#34;] / dt)
        delay = int(self._params[&#34;delay&#34;] / dt)
        if self._mode == &#34;random&#34;:
            values = np.random.uniform(0, 1, size=(self._batch_size))
            inputs = np.zeros((trial_time + delay, self._batch_size, self._ob_size))
            inputs[:trial_time, :, 0] = 1
            inputs[:trial_time, :, 1] = values[:]
            target_outputs = np.zeros(
                (trial_time + delay, self._batch_size, self._act_size)
            )
            target_outputs[:, :, 0] = inputs[:, :, 0]
            target_outputs[trial_time:, :, 1] = values &lt; self.threshold
            target_outputs[trial_time:, :, 2] = values &gt; self.threshold
            return inputs, target_outputs

    def one_dataset(self) -&gt; Tuple[np.ndarray, np.ndarray]:
        return self._one_dataset()


class DMTaskRandomMod(DMTask):
    &#34;&#34;&#34;
    Class method for DMTask class .

    Args:
        DMTask ([type]): [description]
    &#34;&#34;&#34;

    def __init__(
        self, params: Optional[dict] = None, batch_size: int = 1, mode: str = &#34;random&#34;
    ) -&gt; None:
        &#34;&#34;&#34;
        Initialize the model .

        Args:
            batch_size (int): [description]
            params (Optional[dict], optional): [description]. Defaults to None.
            mode (str, optional): [description]. Defaults to &#34;random&#34;.
            n_mods (int, optional): [description]. Defaults to 1.
        &#34;&#34;&#34;
        if params is None:
            params = DefaultParams(&#34;DMTaskRandomMod&#34;).generate_params()
        super().__init__(params, batch_size, mode)
        self._n_mods = params[&#34;n_mods&#34;]
        self._ob_size += self._n_mods - 1

    def _one_dataset_mod(self, mode: int) -&gt; Tuple[np.ndarray, np.ndarray]:
        &#34;&#34;&#34;
        Generate a single dataset .

        Returns:
            Tuple[np.ndarray, np.ndarray]: [inputs, target outputs]
        &#34;&#34;&#34;
        temp, outputs = self._one_dataset()
        T = temp.shape[0]
        inputs = np.zeros((T, self._batch_size, self._ob_size))
        inputs[:, :, 0] = temp[:, :, 0]
        inputs[:, :, 1 + mode] = temp[:, :, 1]
        return inputs, outputs

    def one_dataset(self, mode: Optional[int] = None):
        if mode is None:
            mode = np.random.randint(0, self._n_mods)
        return self._one_dataset_mod(mode)


class DMTask1(DMTaskRandomMod):
    def __init__(
        self, params: Optional[dict] = None, batch_size: int = 1, mode: str = &#34;random&#34;
    ) -&gt; None:
        super().__init__(params, batch_size, mode)

    def one_dataset(self, mode=0):
        return self._one_dataset_mod(mode)


class DMTask2(DMTaskRandomMod):
    def __init__(
        self, params: Optional[dict] = None, batch_size: int = 1, mode: str = &#34;random&#34;
    ) -&gt; None:
        super().__init__(params, batch_size, mode)

    def one_dataset(self, mode=0):
        return self._one_dataset_mod(mode)


class RomoTask(ReduceTaskCognitive):
    &#34;&#34;&#34;
    The challenge is for the subjects or the network to
    remember the first stimulus. Then, after the delay time,
    the second stimulus comes. The network must compare this
    incentive and respond correctly.

    Ref: https://www.nature.com/articles/20939


    Args:
        ReduceTaskCognitive ([type]): [description]
    &#34;&#34;&#34;

    def __init__(
        self, params: Optional[dict] = None, batch_size: int = 1, mode: str = &#34;random&#34;
    ) -&gt; None:
        &#34;&#34;&#34;
        Initialize the model .

        Args:
            params (dict): [description]
            batch_size (int): [description]
            mode (str, optional): [description]. Defaults to &#34;random&#34;.
        &#34;&#34;&#34;
        if params is None:
            params = DefaultParams(&#34;RomoTask&#34;).generate_params()
        super().__init__(params, batch_size, mode)
        self._ob_size = 2
        self._act_size = 3

    def _one_dataset(self) -&gt; Tuple[np.ndarray, np.ndarray]:
        &#34;&#34;&#34;
        Returns a single dataset with the given size and target .

        Returns:
            Tuple[np.ndarray, np.ndarray]: [description]
        &#34;&#34;&#34;
        dt = self.params[&#34;dt&#34;]
        trial_time = int(self._params[&#34;trial_time&#34;] / dt)
        delay = int(self._params[&#34;delay&#34;] / dt)
        if self._mode == &#34;random&#34;:
            values_first = np.random.uniform(0, 1, size=(self._batch_size))
            values_second = np.random.uniform(0, 1, size=(self._batch_size))
            # TODO: добавить проверку на совпадения (хотя это маловероятно)
            inputs = np.zeros(
                (2 * (trial_time + delay), self._batch_size, self._ob_size)
            )
            inputs[: 2 * trial_time + delay, :, 0] = 1
            inputs[:trial_time, :, 1] = values_first
            inputs[trial_time + delay : -delay, :, 1] = values_second
            target_output = np.zeros(
                (2 * (trial_time + delay), self._batch_size, self._act_size)
            )
            target_output[:, :, 0] = inputs[:, :, 0]
            target_output[2 * trial_time + delay :, :, 1] = values_first &lt; values_second
            target_output[2 * trial_time + delay :, :, 2] = values_second &lt; values_first
            return inputs, target_output

    def one_dataset(self):
        &#34;&#34;&#34;
        Return a single dataset containing only one dataset .

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        return self._one_dataset()


class RomoTaskRandomMod(RomoTask):
    &#34;&#34;&#34;
    Trial task that is used for a random mod .

    Args:
        RomoTask ([type]): [description]
    &#34;&#34;&#34;

    def __init__(
        self, params: Optional[dict] = None, batch_size: int = 1, mode: str = &#34;random&#34;
    ) -&gt; None:
        &#34;&#34;&#34;
        Initialize the model .

        Args:
            params (dict): [description]
            batch_size (int): [description]
            mode (str, optional): [description]. Defaults to &#34;random&#34;.
            n_mods (int, optional): [description]. Defaults to 1.
        &#34;&#34;&#34;
        if params is None:
            params = DefaultParams(&#34;RomoTaskRandomMod&#34;).generate_params()
        super().__init__(params, batch_size, mode)
        self._n_mods = params[&#34;n_mods&#34;]
        self._ob_size += self._n_mods - 1

    def _one_dataset_mod(self, mode: int):
        &#34;&#34;&#34;
        Generate a single model .

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        temp, outputs = self._one_dataset()
        T = temp.shape[0]
        inputs = np.zeros((T, self._batch_size, self._ob_size))
        inputs[:, :, 0] = temp[:, :, 0]
        inputs[:, :, 1 + mode] = temp[:, :, 1]
        return inputs, outputs

    def one_dataset(self, mode: Optional[int] = None):
        if mode is None:
            mode = np.random.randint(0, self._n_mods)
        return self._one_dataset_mod(mode)


class RomoTask1(RomoTaskRandomMod):
    def __init__(
        self, params: Optional[dict] = None, batch_size: int = 1, mode: str = &#34;random&#34;
    ) -&gt; None:

        super().__init__(params, batch_size, mode)

    def one_dataset(self, mode=0):
        return self._one_dataset_mod(mode)


class RomoTask2(RomoTaskRandomMod):
    def __init__(
        self, params: Optional[dict] = None, batch_size: int = 1, mode: str = &#34;random&#34;
    ) -&gt; None:

        super().__init__(params, batch_size, mode)

    def one_dataset(self, mode=1):
        return self._one_dataset_mod(mode)


class CtxDMTask(ReduceTaskCognitive):
    &#34;&#34;&#34;
    Context manager for CtxDMTask .

    Args:
        ReduceTaskCognitive ([type]): [description]
    &#34;&#34;&#34;

    def __init__(
        self, params: Optional[dict] = None, batch_size: int = 1, mode: str = &#34;random&#34;
    ):
        &#34;&#34;&#34;
        Initialize the DMTask .

        Args:
            params (dict): [description]
            batch_size (int): [description]
            mode (str, optional): [description]. Defaults to &#34;random&#34;.
        &#34;&#34;&#34;
        if params is None:
            params = DefaultParams(&#34;CtxDMTask&#34;).generate_params()
        super().__init__(params, batch_size, mode)

        self.DMTask = DMTask(params, batch_size, mode)
        self._ob_size = 3
        self._act_size = 3

    def _one_dataset(self, context: int):
        &#34;&#34;&#34;
        Returns a single batch of inputs for one or more contexts .

        Args:
            context (int): [description]

        Raises:
            ValueError: [description]

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        inputs_first_context, outputs_first_context = self.DMTask.one_dataset()
        inputs_second_context, outputs_second_context = self.DMTask.one_dataset()
        inputs = np.zeros(
            (inputs_first_context.shape[0], self._batch_size, self._ob_size)
        )
        inputs[:, :, 0] = inputs_first_context[:, :, 0]
        inputs[:, :, 1] = inputs_first_context[:, :, 1]
        inputs[:, :, 2] = inputs_second_context[:, :, 1]
        if context == 0:
            return inputs, outputs_first_context
        if context == 1:
            return inputs, outputs_second_context
        else:
            raise ValueError(f&#34;param: context expected 0 or 1, but actual {context}&#34;)

    def one_dataset(self, context: int = np.random.choice([0, 1]), *args, **kwargs):
        &#34;&#34;&#34;
        Return a single dataset with one context .

        Args:
            context (int, optional): [description]. Defaults to np.random.choice([0, 1]).

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        return self._one_dataset(context)

    @property
    def params(self):
        &#34;&#34;&#34;
        Get a list of parameters .

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        return self._params

    @params.setter
    def params(self, new_params: dict):
        &#34;&#34;&#34;
        Set the parameters of this DMTask .

        Args:
            new_params (dict): [description]
        &#34;&#34;&#34;
        self._params = new_params
        self.DMTask = DMTask(new_params, self._batch_size, self._mode)


class CtxDM1(CtxDMTask):
    &#34;&#34;&#34;
    A context manager for creating a CtxDM1 code .

    Args:
        CtxDMTask ([type]): [description]
    &#34;&#34;&#34;

    def __init__(
        self, params: Optional[dict] = None, batch_size: int = 1, mode: str = &#34;random&#34;
    ):
        &#34;&#34;&#34;
        Initialize the model .

        Args:
            params (dict): [description]
            batch_size (int): [description]
            mode (str, optional): [description]. Defaults to &#34;random&#34;.
        &#34;&#34;&#34;
        super().__init__(params, batch_size, mode)

    def one_dataset(self):
        &#34;&#34;&#34;
        Return single dataset with only one dataset .

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        return self._one_dataset(0)


class CtxDM2(CtxDMTask):
    &#34;&#34;&#34;
    A context manager for creating a CtxDMTask class .

    Args:
        CtxDMTask ([type]): [description]
    &#34;&#34;&#34;

    def __init__(
        self, params: Optional[dict] = None, batch_size: int = 1, mode: str = &#34;random&#34;
    ):
        &#34;&#34;&#34;
        Initialize the model .

        Args:
            params (dict): [description]
            batch_size (int): [description]
            mode (str, optional): [description]. Defaults to &#34;random&#34;.
        &#34;&#34;&#34;
        super().__init__(params, batch_size, mode)

    def one_dataset(self):
        &#34;&#34;&#34;Return a single dataset.&#34;&#34;&#34;
        return self._one_dataset(1)


class MultyReduceTasks(ReduceTaskCognitive):
    &#34;&#34;&#34;
    The class method for creating a multilereduce task .

    Args:
        ReduceTaskCognitive ([list] or [dict]): [If list: list of tasks.
        If dict: dict tasks and their parameters (see [DefaultParameters])]

    Returns:
        [type]: [description]
    &#34;&#34;&#34;

    task_list = [
        (&#34;DMTask&#34;, DMTaskRandomMod),
        (&#34;RomoTask&#34;, RomoTaskRandomMod),
        (&#34;CtxDMTask&#34;, CtxDMTask),
        (&#34;RomoTask1&#34;, RomoTask1),
        (&#34;RomoTask2&#34;, RomoTask2),
        (&#34;DMTask1&#34;, DMTask1),
        (&#34;DMTask2&#34;, DMTask2),
        (&#34;CtxDMTask1&#34;, CtxDM1),
        (&#34;CtxDMTask2&#34;, CtxDM2),
    ]
    task_list.sort()
    TASKSDICT = dict(task_list)
    n_mods = 2

    def __init__(
        self,
        tasks: Union[dict[str, dict[str, float]], list[str]],
        batch_size: int = 1,
        mode: str = &#34;random&#34;,
    ):
        &#34;&#34;&#34;
        Initialize the object with the initial state of the model .

        Args:
            tasks (Union[dict[str, dict[str, float]], list[str]]): [description]
            batch_size (int, optional): [description]. Defaults to 1.
            mode (str, optional): [description]. Defaults to &#34;random&#34;.
        &#34;&#34;&#34;
        self._initial_tasks_list = dict()
        if type(tasks) == list:
            for task_name in tasks:
                self._initial_tasks_list[task_name] = self.TASKSDICT[task_name](
                    batch_size=batch_size, mode=mode
                )
        if type(tasks) == dict:
            for task_name in tasks:
                self._initial_tasks_list[task_name] = self.TASKSDICT[task_name](
                    params=tasks[task_name], batch_size=batch_size, mode=mode
                )
        self._tasks = tasks
        self._ob_size = 3 + len(tasks)
        self._act_size = 3
        self._sorted_tasks()
        self._create_task_list()
        self._batch_size = batch_size

    def _one_dataset(self) -&gt; Tuple[np.ndarray, np.ndarray]:
        &#34;&#34;&#34;
        Runs one step of the batch .

        Returns:
            Tuple[np.ndarray, np.ndarray]: [description]
        &#34;&#34;&#34;
        current_task = np.random.choice([i for i in range(len(self._task_list))])

        inputs, outputs = self._task_list[current_task].one_dataset()
        inputs_plus_rule = np.zeros((inputs.shape[0], self._batch_size, self._ob_size))
        inputs_plus_rule[:, :, -len(self._task_list) + current_task] = 1
        inputs_plus_rule[:, :, : -len(self._task_list)] = inputs
        return inputs_plus_rule, outputs

    def one_dataset(self):
        return self._one_dataset()

    def _create_task_list(self):
        self._task_list = [
            self._initial_tasks_list[task_name]
            for task_name in self._initial_tasks_list
        ]

    def _sorted_tasks(self):
        &#34;&#34;&#34;
        sort the tasks in order to avoid duplicates
        &#34;&#34;&#34;
        new_dict = dict()
        for task_name in sorted(self._initial_tasks_list):
            new_dict[task_name] = self._initial_tasks_list[task_name]
        self._initial_tasks_list = new_dict

    @property
    def feature_and_act_size(self) -&gt; Tuple[int, int]:
        &#34;&#34;&#34;
        Return the feature and act size .

        Returns:
            Tuple[int, int]: [description]
        &#34;&#34;&#34;
        return self._ob_size, self._act_size

    @property
    def feature_and_act_every_task_size(self) -&gt; dict[str, Tuple[int, int]]:
        &#34;&#34;&#34;
        Returns a dictionary of feature and action for each task.

        Returns:
            dict[str, Tuple[int, int]]: [description]
        &#34;&#34;&#34;
        ob_and_act_sizes = dict()
        for task_name in self._initial_tasks_list:
            ob_size, act_size = self._initial_tasks_list[task_name].feature_and_act_size
            ob_and_act_sizes[task_name] = (ob_size, act_size)
        return ob_and_act_sizes</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tasks.reduce.CtxDM1"><code class="flex name class">
<span>class <span class="ident">CtxDM1</span></span>
<span>(</span><span>params: Optional[dict] = None, batch_size: int = 1, mode: str = 'random')</span>
</code></dt>
<dd>
<div class="desc"><p>A context manager for creating a CtxDM1 code .</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CtxDMTask</code></strong> :&ensp;<code>[type]</code></dt>
<dd>[description]</dd>
</dl>
<p>Initialize the model .</p>
<h2 id="args_1">Args</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>dict</code></dt>
<dd>[description]</dd>
<dt><strong><code>batch_size</code></strong> :&ensp;<code>int</code></dt>
<dd>[description]</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>[description]. Defaults to "random".</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CtxDM1(CtxDMTask):
    &#34;&#34;&#34;
    A context manager for creating a CtxDM1 code .

    Args:
        CtxDMTask ([type]): [description]
    &#34;&#34;&#34;

    def __init__(
        self, params: Optional[dict] = None, batch_size: int = 1, mode: str = &#34;random&#34;
    ):
        &#34;&#34;&#34;
        Initialize the model .

        Args:
            params (dict): [description]
            batch_size (int): [description]
            mode (str, optional): [description]. Defaults to &#34;random&#34;.
        &#34;&#34;&#34;
        super().__init__(params, batch_size, mode)

    def one_dataset(self):
        &#34;&#34;&#34;
        Return single dataset with only one dataset .

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        return self._one_dataset(0)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tasks.reduce.CtxDMTask" href="#tasks.reduce.CtxDMTask">CtxDMTask</a></li>
<li><a title="tasks.reduce.ReduceTaskCognitive" href="#tasks.reduce.ReduceTaskCognitive">ReduceTaskCognitive</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="tasks.reduce.CtxDM1.one_dataset"><code class="name flex">
<span>def <span class="ident">one_dataset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return single dataset with only one dataset .</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>[type]</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def one_dataset(self):
    &#34;&#34;&#34;
    Return single dataset with only one dataset .

    Returns:
        [type]: [description]
    &#34;&#34;&#34;
    return self._one_dataset(0)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="tasks.reduce.CtxDMTask" href="#tasks.reduce.CtxDMTask">CtxDMTask</a></b></code>:
<ul class="hlist">
<li><code><a title="tasks.reduce.CtxDMTask.batch_size" href="#tasks.reduce.ReduceTaskCognitive.batch_size">batch_size</a></code></li>
<li><code><a title="tasks.reduce.CtxDMTask.feature_and_act_size" href="#tasks.reduce.ReduceTaskCognitive.feature_and_act_size">feature_and_act_size</a></code></li>
<li><code><a title="tasks.reduce.CtxDMTask.params" href="#tasks.reduce.CtxDMTask.params">params</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="tasks.reduce.CtxDM2"><code class="flex name class">
<span>class <span class="ident">CtxDM2</span></span>
<span>(</span><span>params: Optional[dict] = None, batch_size: int = 1, mode: str = 'random')</span>
</code></dt>
<dd>
<div class="desc"><p>A context manager for creating a CtxDMTask class .</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>CtxDMTask</code></strong> :&ensp;<code>[type]</code></dt>
<dd>[description]</dd>
</dl>
<p>Initialize the model .</p>
<h2 id="args_1">Args</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>dict</code></dt>
<dd>[description]</dd>
<dt><strong><code>batch_size</code></strong> :&ensp;<code>int</code></dt>
<dd>[description]</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>[description]. Defaults to "random".</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CtxDM2(CtxDMTask):
    &#34;&#34;&#34;
    A context manager for creating a CtxDMTask class .

    Args:
        CtxDMTask ([type]): [description]
    &#34;&#34;&#34;

    def __init__(
        self, params: Optional[dict] = None, batch_size: int = 1, mode: str = &#34;random&#34;
    ):
        &#34;&#34;&#34;
        Initialize the model .

        Args:
            params (dict): [description]
            batch_size (int): [description]
            mode (str, optional): [description]. Defaults to &#34;random&#34;.
        &#34;&#34;&#34;
        super().__init__(params, batch_size, mode)

    def one_dataset(self):
        &#34;&#34;&#34;Return a single dataset.&#34;&#34;&#34;
        return self._one_dataset(1)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tasks.reduce.CtxDMTask" href="#tasks.reduce.CtxDMTask">CtxDMTask</a></li>
<li><a title="tasks.reduce.ReduceTaskCognitive" href="#tasks.reduce.ReduceTaskCognitive">ReduceTaskCognitive</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="tasks.reduce.CtxDM2.one_dataset"><code class="name flex">
<span>def <span class="ident">one_dataset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a single dataset.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def one_dataset(self):
    &#34;&#34;&#34;Return a single dataset.&#34;&#34;&#34;
    return self._one_dataset(1)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="tasks.reduce.CtxDMTask" href="#tasks.reduce.CtxDMTask">CtxDMTask</a></b></code>:
<ul class="hlist">
<li><code><a title="tasks.reduce.CtxDMTask.batch_size" href="#tasks.reduce.ReduceTaskCognitive.batch_size">batch_size</a></code></li>
<li><code><a title="tasks.reduce.CtxDMTask.feature_and_act_size" href="#tasks.reduce.ReduceTaskCognitive.feature_and_act_size">feature_and_act_size</a></code></li>
<li><code><a title="tasks.reduce.CtxDMTask.params" href="#tasks.reduce.CtxDMTask.params">params</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="tasks.reduce.CtxDMTask"><code class="flex name class">
<span>class <span class="ident">CtxDMTask</span></span>
<span>(</span><span>params: Optional[dict] = None, batch_size: int = 1, mode: str = 'random')</span>
</code></dt>
<dd>
<div class="desc"><p>Context manager for CtxDMTask .</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ReduceTaskCognitive</code></strong> :&ensp;<code>[type]</code></dt>
<dd>[description]</dd>
</dl>
<p>Initialize the DMTask .</p>
<h2 id="args_1">Args</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>dict</code></dt>
<dd>[description]</dd>
<dt><strong><code>batch_size</code></strong> :&ensp;<code>int</code></dt>
<dd>[description]</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>[description]. Defaults to "random".</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CtxDMTask(ReduceTaskCognitive):
    &#34;&#34;&#34;
    Context manager for CtxDMTask .

    Args:
        ReduceTaskCognitive ([type]): [description]
    &#34;&#34;&#34;

    def __init__(
        self, params: Optional[dict] = None, batch_size: int = 1, mode: str = &#34;random&#34;
    ):
        &#34;&#34;&#34;
        Initialize the DMTask .

        Args:
            params (dict): [description]
            batch_size (int): [description]
            mode (str, optional): [description]. Defaults to &#34;random&#34;.
        &#34;&#34;&#34;
        if params is None:
            params = DefaultParams(&#34;CtxDMTask&#34;).generate_params()
        super().__init__(params, batch_size, mode)

        self.DMTask = DMTask(params, batch_size, mode)
        self._ob_size = 3
        self._act_size = 3

    def _one_dataset(self, context: int):
        &#34;&#34;&#34;
        Returns a single batch of inputs for one or more contexts .

        Args:
            context (int): [description]

        Raises:
            ValueError: [description]

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        inputs_first_context, outputs_first_context = self.DMTask.one_dataset()
        inputs_second_context, outputs_second_context = self.DMTask.one_dataset()
        inputs = np.zeros(
            (inputs_first_context.shape[0], self._batch_size, self._ob_size)
        )
        inputs[:, :, 0] = inputs_first_context[:, :, 0]
        inputs[:, :, 1] = inputs_first_context[:, :, 1]
        inputs[:, :, 2] = inputs_second_context[:, :, 1]
        if context == 0:
            return inputs, outputs_first_context
        if context == 1:
            return inputs, outputs_second_context
        else:
            raise ValueError(f&#34;param: context expected 0 or 1, but actual {context}&#34;)

    def one_dataset(self, context: int = np.random.choice([0, 1]), *args, **kwargs):
        &#34;&#34;&#34;
        Return a single dataset with one context .

        Args:
            context (int, optional): [description]. Defaults to np.random.choice([0, 1]).

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        return self._one_dataset(context)

    @property
    def params(self):
        &#34;&#34;&#34;
        Get a list of parameters .

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        return self._params

    @params.setter
    def params(self, new_params: dict):
        &#34;&#34;&#34;
        Set the parameters of this DMTask .

        Args:
            new_params (dict): [description]
        &#34;&#34;&#34;
        self._params = new_params
        self.DMTask = DMTask(new_params, self._batch_size, self._mode)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tasks.reduce.ReduceTaskCognitive" href="#tasks.reduce.ReduceTaskCognitive">ReduceTaskCognitive</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="tasks.reduce.CtxDM1" href="#tasks.reduce.CtxDM1">CtxDM1</a></li>
<li><a title="tasks.reduce.CtxDM2" href="#tasks.reduce.CtxDM2">CtxDM2</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="tasks.reduce.CtxDMTask.params"><code class="name">var <span class="ident">params</span></code></dt>
<dd>
<div class="desc"><p>Get a list of parameters .</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>[type]</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def params(self):
    &#34;&#34;&#34;
    Get a list of parameters .

    Returns:
        [type]: [description]
    &#34;&#34;&#34;
    return self._params</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tasks.reduce.CtxDMTask.one_dataset"><code class="name flex">
<span>def <span class="ident">one_dataset</span></span>(<span>self, context: int = 0, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a single dataset with one context .</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>context</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>[description]. Defaults to np.random.choice([0, 1]).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>[type]</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def one_dataset(self, context: int = np.random.choice([0, 1]), *args, **kwargs):
    &#34;&#34;&#34;
    Return a single dataset with one context .

    Args:
        context (int, optional): [description]. Defaults to np.random.choice([0, 1]).

    Returns:
        [type]: [description]
    &#34;&#34;&#34;
    return self._one_dataset(context)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="tasks.reduce.ReduceTaskCognitive" href="#tasks.reduce.ReduceTaskCognitive">ReduceTaskCognitive</a></b></code>:
<ul class="hlist">
<li><code><a title="tasks.reduce.ReduceTaskCognitive.batch_size" href="#tasks.reduce.ReduceTaskCognitive.batch_size">batch_size</a></code></li>
<li><code><a title="tasks.reduce.ReduceTaskCognitive.feature_and_act_size" href="#tasks.reduce.ReduceTaskCognitive.feature_and_act_size">feature_and_act_size</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="tasks.reduce.DMTask"><code class="flex name class">
<span>class <span class="ident">DMTask</span></span>
<span>(</span><span>params: Optional[dict] = None, batch_size: int = 1, mode: str = 'random')</span>
</code></dt>
<dd>
<div class="desc"><p>Construct a DMTask class for DMTask .</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ReduceTaskCognitive</code></strong> :&ensp;<code>[type]</code></dt>
<dd>[description]</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>[type]</code></dt>
<dd>[description]</dd>
</dl>
<p>Initialize the model .</p>
<h2 id="args_1">Args</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>Optional[dict]</code>, optional</dt>
<dd>[description]. Defaults to None.</dd>
<dt><strong><code>batch_size</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>[description]. Defaults to 1.</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>[description]. Defaults to "random".</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DMTask(ReduceTaskCognitive):
    &#34;&#34;&#34;
    Construct a DMTask class for DMTask .

    Args:
        ReduceTaskCognitive ([type]): [description]

    Returns:
        [type]: [description]
    &#34;&#34;&#34;

    threshold = 0.5

    def __init__(
        self, params: Optional[dict] = None, batch_size: int = 1, mode: str = &#34;random&#34;
    ) -&gt; None:
        &#34;&#34;&#34;
        Initialize the model .

        Args:
            params (Optional[dict], optional): [description]. Defaults to None.
            batch_size (int, optional): [description]. Defaults to 1.
            mode (str, optional): [description]. Defaults to &#34;random&#34;.
        &#34;&#34;&#34;
        if params is None:
            params = DefaultParams(&#34;DMTask&#34;).generate_params()
        super().__init__(params, batch_size, mode)
        self._ob_size = 2
        self._act_size = 3

    def _one_dataset(self) -&gt; Tuple[np.ndarray, np.ndarray]:
        &#34;&#34;&#34;
        Returns a single dataset with inputs and target outputs .

        Returns:
            Tuple[np.ndarray, np.ndarray]: [inputs, outputs]
        &#34;&#34;&#34;
        dt = self._params[&#34;dt&#34;]
        trial_time = int(self._params[&#34;trial_time&#34;] / dt)
        delay = int(self._params[&#34;delay&#34;] / dt)
        if self._mode == &#34;random&#34;:
            values = np.random.uniform(0, 1, size=(self._batch_size))
            inputs = np.zeros((trial_time + delay, self._batch_size, self._ob_size))
            inputs[:trial_time, :, 0] = 1
            inputs[:trial_time, :, 1] = values[:]
            target_outputs = np.zeros(
                (trial_time + delay, self._batch_size, self._act_size)
            )
            target_outputs[:, :, 0] = inputs[:, :, 0]
            target_outputs[trial_time:, :, 1] = values &lt; self.threshold
            target_outputs[trial_time:, :, 2] = values &gt; self.threshold
            return inputs, target_outputs

    def one_dataset(self) -&gt; Tuple[np.ndarray, np.ndarray]:
        return self._one_dataset()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tasks.reduce.ReduceTaskCognitive" href="#tasks.reduce.ReduceTaskCognitive">ReduceTaskCognitive</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="tasks.reduce.DMTaskRandomMod" href="#tasks.reduce.DMTaskRandomMod">DMTaskRandomMod</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="tasks.reduce.DMTask.threshold"><code class="name">var <span class="ident">threshold</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="tasks.reduce.ReduceTaskCognitive" href="#tasks.reduce.ReduceTaskCognitive">ReduceTaskCognitive</a></b></code>:
<ul class="hlist">
<li><code><a title="tasks.reduce.ReduceTaskCognitive.batch_size" href="#tasks.reduce.ReduceTaskCognitive.batch_size">batch_size</a></code></li>
<li><code><a title="tasks.reduce.ReduceTaskCognitive.feature_and_act_size" href="#tasks.reduce.ReduceTaskCognitive.feature_and_act_size">feature_and_act_size</a></code></li>
<li><code><a title="tasks.reduce.ReduceTaskCognitive.one_dataset" href="#tasks.reduce.ReduceTaskCognitive.one_dataset">one_dataset</a></code></li>
<li><code><a title="tasks.reduce.ReduceTaskCognitive.params" href="#tasks.reduce.ReduceTaskCognitive.params">params</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="tasks.reduce.DMTask1"><code class="flex name class">
<span>class <span class="ident">DMTask1</span></span>
<span>(</span><span>params: Optional[dict] = None, batch_size: int = 1, mode: str = 'random')</span>
</code></dt>
<dd>
<div class="desc"><p>Class method for DMTask class .</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>DMTask</code></strong> :&ensp;<code>[type]</code></dt>
<dd>[description]</dd>
</dl>
<p>Initialize the model .</p>
<h2 id="args_1">Args</h2>
<dl>
<dt><strong><code>batch_size</code></strong> :&ensp;<code>int</code></dt>
<dd>[description]</dd>
<dt><strong><code>params</code></strong> :&ensp;<code>Optional[dict]</code>, optional</dt>
<dd>[description]. Defaults to None.</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>[description]. Defaults to "random".</dd>
<dt><strong><code>n_mods</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>[description]. Defaults to 1.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DMTask1(DMTaskRandomMod):
    def __init__(
        self, params: Optional[dict] = None, batch_size: int = 1, mode: str = &#34;random&#34;
    ) -&gt; None:
        super().__init__(params, batch_size, mode)

    def one_dataset(self, mode=0):
        return self._one_dataset_mod(mode)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tasks.reduce.DMTaskRandomMod" href="#tasks.reduce.DMTaskRandomMod">DMTaskRandomMod</a></li>
<li><a title="tasks.reduce.DMTask" href="#tasks.reduce.DMTask">DMTask</a></li>
<li><a title="tasks.reduce.ReduceTaskCognitive" href="#tasks.reduce.ReduceTaskCognitive">ReduceTaskCognitive</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="tasks.reduce.DMTaskRandomMod" href="#tasks.reduce.DMTaskRandomMod">DMTaskRandomMod</a></b></code>:
<ul class="hlist">
<li><code><a title="tasks.reduce.DMTaskRandomMod.batch_size" href="#tasks.reduce.ReduceTaskCognitive.batch_size">batch_size</a></code></li>
<li><code><a title="tasks.reduce.DMTaskRandomMod.feature_and_act_size" href="#tasks.reduce.ReduceTaskCognitive.feature_and_act_size">feature_and_act_size</a></code></li>
<li><code><a title="tasks.reduce.DMTaskRandomMod.one_dataset" href="#tasks.reduce.ReduceTaskCognitive.one_dataset">one_dataset</a></code></li>
<li><code><a title="tasks.reduce.DMTaskRandomMod.params" href="#tasks.reduce.ReduceTaskCognitive.params">params</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="tasks.reduce.DMTask2"><code class="flex name class">
<span>class <span class="ident">DMTask2</span></span>
<span>(</span><span>params: Optional[dict] = None, batch_size: int = 1, mode: str = 'random')</span>
</code></dt>
<dd>
<div class="desc"><p>Class method for DMTask class .</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>DMTask</code></strong> :&ensp;<code>[type]</code></dt>
<dd>[description]</dd>
</dl>
<p>Initialize the model .</p>
<h2 id="args_1">Args</h2>
<dl>
<dt><strong><code>batch_size</code></strong> :&ensp;<code>int</code></dt>
<dd>[description]</dd>
<dt><strong><code>params</code></strong> :&ensp;<code>Optional[dict]</code>, optional</dt>
<dd>[description]. Defaults to None.</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>[description]. Defaults to "random".</dd>
<dt><strong><code>n_mods</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>[description]. Defaults to 1.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DMTask2(DMTaskRandomMod):
    def __init__(
        self, params: Optional[dict] = None, batch_size: int = 1, mode: str = &#34;random&#34;
    ) -&gt; None:
        super().__init__(params, batch_size, mode)

    def one_dataset(self, mode=0):
        return self._one_dataset_mod(mode)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tasks.reduce.DMTaskRandomMod" href="#tasks.reduce.DMTaskRandomMod">DMTaskRandomMod</a></li>
<li><a title="tasks.reduce.DMTask" href="#tasks.reduce.DMTask">DMTask</a></li>
<li><a title="tasks.reduce.ReduceTaskCognitive" href="#tasks.reduce.ReduceTaskCognitive">ReduceTaskCognitive</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="tasks.reduce.DMTaskRandomMod" href="#tasks.reduce.DMTaskRandomMod">DMTaskRandomMod</a></b></code>:
<ul class="hlist">
<li><code><a title="tasks.reduce.DMTaskRandomMod.batch_size" href="#tasks.reduce.ReduceTaskCognitive.batch_size">batch_size</a></code></li>
<li><code><a title="tasks.reduce.DMTaskRandomMod.feature_and_act_size" href="#tasks.reduce.ReduceTaskCognitive.feature_and_act_size">feature_and_act_size</a></code></li>
<li><code><a title="tasks.reduce.DMTaskRandomMod.one_dataset" href="#tasks.reduce.ReduceTaskCognitive.one_dataset">one_dataset</a></code></li>
<li><code><a title="tasks.reduce.DMTaskRandomMod.params" href="#tasks.reduce.ReduceTaskCognitive.params">params</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="tasks.reduce.DMTaskRandomMod"><code class="flex name class">
<span>class <span class="ident">DMTaskRandomMod</span></span>
<span>(</span><span>params: Optional[dict] = None, batch_size: int = 1, mode: str = 'random')</span>
</code></dt>
<dd>
<div class="desc"><p>Class method for DMTask class .</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>DMTask</code></strong> :&ensp;<code>[type]</code></dt>
<dd>[description]</dd>
</dl>
<p>Initialize the model .</p>
<h2 id="args_1">Args</h2>
<dl>
<dt><strong><code>batch_size</code></strong> :&ensp;<code>int</code></dt>
<dd>[description]</dd>
<dt><strong><code>params</code></strong> :&ensp;<code>Optional[dict]</code>, optional</dt>
<dd>[description]. Defaults to None.</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>[description]. Defaults to "random".</dd>
<dt><strong><code>n_mods</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>[description]. Defaults to 1.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DMTaskRandomMod(DMTask):
    &#34;&#34;&#34;
    Class method for DMTask class .

    Args:
        DMTask ([type]): [description]
    &#34;&#34;&#34;

    def __init__(
        self, params: Optional[dict] = None, batch_size: int = 1, mode: str = &#34;random&#34;
    ) -&gt; None:
        &#34;&#34;&#34;
        Initialize the model .

        Args:
            batch_size (int): [description]
            params (Optional[dict], optional): [description]. Defaults to None.
            mode (str, optional): [description]. Defaults to &#34;random&#34;.
            n_mods (int, optional): [description]. Defaults to 1.
        &#34;&#34;&#34;
        if params is None:
            params = DefaultParams(&#34;DMTaskRandomMod&#34;).generate_params()
        super().__init__(params, batch_size, mode)
        self._n_mods = params[&#34;n_mods&#34;]
        self._ob_size += self._n_mods - 1

    def _one_dataset_mod(self, mode: int) -&gt; Tuple[np.ndarray, np.ndarray]:
        &#34;&#34;&#34;
        Generate a single dataset .

        Returns:
            Tuple[np.ndarray, np.ndarray]: [inputs, target outputs]
        &#34;&#34;&#34;
        temp, outputs = self._one_dataset()
        T = temp.shape[0]
        inputs = np.zeros((T, self._batch_size, self._ob_size))
        inputs[:, :, 0] = temp[:, :, 0]
        inputs[:, :, 1 + mode] = temp[:, :, 1]
        return inputs, outputs

    def one_dataset(self, mode: Optional[int] = None):
        if mode is None:
            mode = np.random.randint(0, self._n_mods)
        return self._one_dataset_mod(mode)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tasks.reduce.DMTask" href="#tasks.reduce.DMTask">DMTask</a></li>
<li><a title="tasks.reduce.ReduceTaskCognitive" href="#tasks.reduce.ReduceTaskCognitive">ReduceTaskCognitive</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="tasks.reduce.DMTask1" href="#tasks.reduce.DMTask1">DMTask1</a></li>
<li><a title="tasks.reduce.DMTask2" href="#tasks.reduce.DMTask2">DMTask2</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="tasks.reduce.DMTask" href="#tasks.reduce.DMTask">DMTask</a></b></code>:
<ul class="hlist">
<li><code><a title="tasks.reduce.DMTask.batch_size" href="#tasks.reduce.ReduceTaskCognitive.batch_size">batch_size</a></code></li>
<li><code><a title="tasks.reduce.DMTask.feature_and_act_size" href="#tasks.reduce.ReduceTaskCognitive.feature_and_act_size">feature_and_act_size</a></code></li>
<li><code><a title="tasks.reduce.DMTask.one_dataset" href="#tasks.reduce.ReduceTaskCognitive.one_dataset">one_dataset</a></code></li>
<li><code><a title="tasks.reduce.DMTask.params" href="#tasks.reduce.ReduceTaskCognitive.params">params</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="tasks.reduce.DefaultParams"><code class="flex name class">
<span>class <span class="ident">DefaultParams</span></span>
<span>(</span><span>task: str)</span>
</code></dt>
<dd>
<div class="desc"><p>This method is used to create a new Params class .</p>
<p>Initialize the task.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>task</code></strong> :&ensp;<code>str</code></dt>
<dd>[Name of task]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DefaultParams:
    &#34;&#34;&#34;
    This method is used to create a new Params class .
    &#34;&#34;&#34;

    def __init__(self, task: str):
        &#34;&#34;&#34;
        Initialize the task.

        Args:
            task (str): [Name of task]
        &#34;&#34;&#34;
        self._task = task

    def generate_params(self):
        &#34;&#34;&#34;
        Generate parameters for the task .

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        if self._task == &#34;DMTask&#34;:
            return dict([(&#34;dt&#34;, 1e-3), (&#34;delay&#34;, 0.3), (&#34;trial_time&#34;, 0.75)])
        elif self._task == &#34;RomoTask&#34;:
            return dict([(&#34;dt&#34;, 1e-3), (&#34;delay&#34;, 0.3), (&#34;trial_time&#34;, 0.25)])
        elif self._task == &#34;CtxDMTask&#34;:
            return dict([(&#34;dt&#34;, 1e-3), (&#34;delay&#34;, 0.3), (&#34;trial_time&#34;, 0.75)])
        elif self._task == &#34;DMTaskRandomMod&#34;:
            return dict(
                [(&#34;dt&#34;, 1e-3), (&#34;delay&#34;, 0.3), (&#34;trial_time&#34;, 0.75), (&#34;n_mods&#34;, 2)]
            )
        elif self._task == &#34;RomoTaskRandomMod&#34;:
            return dict(
                [(&#34;dt&#34;, 1e-3), (&#34;delay&#34;, 0.3), (&#34;trial_time&#34;, 0.25), (&#34;n_mods&#34;, 2)]
            )
        else:
            raise ValueError(f&#34;Task: {self._task} is not supported&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="tasks.reduce.DefaultParams.generate_params"><code class="name flex">
<span>def <span class="ident">generate_params</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate parameters for the task .</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>[type]</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_params(self):
    &#34;&#34;&#34;
    Generate parameters for the task .

    Returns:
        [type]: [description]
    &#34;&#34;&#34;
    if self._task == &#34;DMTask&#34;:
        return dict([(&#34;dt&#34;, 1e-3), (&#34;delay&#34;, 0.3), (&#34;trial_time&#34;, 0.75)])
    elif self._task == &#34;RomoTask&#34;:
        return dict([(&#34;dt&#34;, 1e-3), (&#34;delay&#34;, 0.3), (&#34;trial_time&#34;, 0.25)])
    elif self._task == &#34;CtxDMTask&#34;:
        return dict([(&#34;dt&#34;, 1e-3), (&#34;delay&#34;, 0.3), (&#34;trial_time&#34;, 0.75)])
    elif self._task == &#34;DMTaskRandomMod&#34;:
        return dict(
            [(&#34;dt&#34;, 1e-3), (&#34;delay&#34;, 0.3), (&#34;trial_time&#34;, 0.75), (&#34;n_mods&#34;, 2)]
        )
    elif self._task == &#34;RomoTaskRandomMod&#34;:
        return dict(
            [(&#34;dt&#34;, 1e-3), (&#34;delay&#34;, 0.3), (&#34;trial_time&#34;, 0.25), (&#34;n_mods&#34;, 2)]
        )
    else:
        raise ValueError(f&#34;Task: {self._task} is not supported&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tasks.reduce.MultyReduceTasks"><code class="flex name class">
<span>class <span class="ident">MultyReduceTasks</span></span>
<span>(</span><span>tasks: Union[dict[str, dict[str, float]], list[str]], batch_size: int = 1, mode: str = 'random')</span>
</code></dt>
<dd>
<div class="desc"><p>The class method for creating a multilereduce task .</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ReduceTaskCognitive</code></strong> :&ensp;<code>[list]</code> or <code>[dict]</code></dt>
<dd>[If list: list of tasks.</dd>
</dl>
<p>If dict: dict tasks and their parameters (see [DefaultParameters])]</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>[type]</code></dt>
<dd>[description]</dd>
</dl>
<p>Initialize the object with the initial state of the model .</p>
<h2 id="args_1">Args</h2>
<dl>
<dt><strong><code>tasks</code></strong> :&ensp;<code>Union[dict[str, dict[str, float]], list[str]]</code></dt>
<dd>[description]</dd>
<dt><strong><code>batch_size</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>[description]. Defaults to 1.</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>[description]. Defaults to "random".</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MultyReduceTasks(ReduceTaskCognitive):
    &#34;&#34;&#34;
    The class method for creating a multilereduce task .

    Args:
        ReduceTaskCognitive ([list] or [dict]): [If list: list of tasks.
        If dict: dict tasks and their parameters (see [DefaultParameters])]

    Returns:
        [type]: [description]
    &#34;&#34;&#34;

    task_list = [
        (&#34;DMTask&#34;, DMTaskRandomMod),
        (&#34;RomoTask&#34;, RomoTaskRandomMod),
        (&#34;CtxDMTask&#34;, CtxDMTask),
        (&#34;RomoTask1&#34;, RomoTask1),
        (&#34;RomoTask2&#34;, RomoTask2),
        (&#34;DMTask1&#34;, DMTask1),
        (&#34;DMTask2&#34;, DMTask2),
        (&#34;CtxDMTask1&#34;, CtxDM1),
        (&#34;CtxDMTask2&#34;, CtxDM2),
    ]
    task_list.sort()
    TASKSDICT = dict(task_list)
    n_mods = 2

    def __init__(
        self,
        tasks: Union[dict[str, dict[str, float]], list[str]],
        batch_size: int = 1,
        mode: str = &#34;random&#34;,
    ):
        &#34;&#34;&#34;
        Initialize the object with the initial state of the model .

        Args:
            tasks (Union[dict[str, dict[str, float]], list[str]]): [description]
            batch_size (int, optional): [description]. Defaults to 1.
            mode (str, optional): [description]. Defaults to &#34;random&#34;.
        &#34;&#34;&#34;
        self._initial_tasks_list = dict()
        if type(tasks) == list:
            for task_name in tasks:
                self._initial_tasks_list[task_name] = self.TASKSDICT[task_name](
                    batch_size=batch_size, mode=mode
                )
        if type(tasks) == dict:
            for task_name in tasks:
                self._initial_tasks_list[task_name] = self.TASKSDICT[task_name](
                    params=tasks[task_name], batch_size=batch_size, mode=mode
                )
        self._tasks = tasks
        self._ob_size = 3 + len(tasks)
        self._act_size = 3
        self._sorted_tasks()
        self._create_task_list()
        self._batch_size = batch_size

    def _one_dataset(self) -&gt; Tuple[np.ndarray, np.ndarray]:
        &#34;&#34;&#34;
        Runs one step of the batch .

        Returns:
            Tuple[np.ndarray, np.ndarray]: [description]
        &#34;&#34;&#34;
        current_task = np.random.choice([i for i in range(len(self._task_list))])

        inputs, outputs = self._task_list[current_task].one_dataset()
        inputs_plus_rule = np.zeros((inputs.shape[0], self._batch_size, self._ob_size))
        inputs_plus_rule[:, :, -len(self._task_list) + current_task] = 1
        inputs_plus_rule[:, :, : -len(self._task_list)] = inputs
        return inputs_plus_rule, outputs

    def one_dataset(self):
        return self._one_dataset()

    def _create_task_list(self):
        self._task_list = [
            self._initial_tasks_list[task_name]
            for task_name in self._initial_tasks_list
        ]

    def _sorted_tasks(self):
        &#34;&#34;&#34;
        sort the tasks in order to avoid duplicates
        &#34;&#34;&#34;
        new_dict = dict()
        for task_name in sorted(self._initial_tasks_list):
            new_dict[task_name] = self._initial_tasks_list[task_name]
        self._initial_tasks_list = new_dict

    @property
    def feature_and_act_size(self) -&gt; Tuple[int, int]:
        &#34;&#34;&#34;
        Return the feature and act size .

        Returns:
            Tuple[int, int]: [description]
        &#34;&#34;&#34;
        return self._ob_size, self._act_size

    @property
    def feature_and_act_every_task_size(self) -&gt; dict[str, Tuple[int, int]]:
        &#34;&#34;&#34;
        Returns a dictionary of feature and action for each task.

        Returns:
            dict[str, Tuple[int, int]]: [description]
        &#34;&#34;&#34;
        ob_and_act_sizes = dict()
        for task_name in self._initial_tasks_list:
            ob_size, act_size = self._initial_tasks_list[task_name].feature_and_act_size
            ob_and_act_sizes[task_name] = (ob_size, act_size)
        return ob_and_act_sizes</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tasks.reduce.ReduceTaskCognitive" href="#tasks.reduce.ReduceTaskCognitive">ReduceTaskCognitive</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="tasks.reduce.MultyReduceTasks.TASKSDICT"><code class="name">var <span class="ident">TASKSDICT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tasks.reduce.MultyReduceTasks.n_mods"><code class="name">var <span class="ident">n_mods</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tasks.reduce.MultyReduceTasks.task_list"><code class="name">var <span class="ident">task_list</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="tasks.reduce.MultyReduceTasks.feature_and_act_every_task_size"><code class="name">var <span class="ident">feature_and_act_every_task_size</span> : dict[str, typing.Tuple[int, int]]</code></dt>
<dd>
<div class="desc"><p>Returns a dictionary of feature and action for each task.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict[str, Tuple[int, int]]</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def feature_and_act_every_task_size(self) -&gt; dict[str, Tuple[int, int]]:
    &#34;&#34;&#34;
    Returns a dictionary of feature and action for each task.

    Returns:
        dict[str, Tuple[int, int]]: [description]
    &#34;&#34;&#34;
    ob_and_act_sizes = dict()
    for task_name in self._initial_tasks_list:
        ob_size, act_size = self._initial_tasks_list[task_name].feature_and_act_size
        ob_and_act_sizes[task_name] = (ob_size, act_size)
    return ob_and_act_sizes</code></pre>
</details>
</dd>
<dt id="tasks.reduce.MultyReduceTasks.feature_and_act_size"><code class="name">var <span class="ident">feature_and_act_size</span> : Tuple[int, int]</code></dt>
<dd>
<div class="desc"><p>Return the feature and act size .</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[int, int]</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def feature_and_act_size(self) -&gt; Tuple[int, int]:
    &#34;&#34;&#34;
    Return the feature and act size .

    Returns:
        Tuple[int, int]: [description]
    &#34;&#34;&#34;
    return self._ob_size, self._act_size</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="tasks.reduce.ReduceTaskCognitive" href="#tasks.reduce.ReduceTaskCognitive">ReduceTaskCognitive</a></b></code>:
<ul class="hlist">
<li><code><a title="tasks.reduce.ReduceTaskCognitive.batch_size" href="#tasks.reduce.ReduceTaskCognitive.batch_size">batch_size</a></code></li>
<li><code><a title="tasks.reduce.ReduceTaskCognitive.one_dataset" href="#tasks.reduce.ReduceTaskCognitive.one_dataset">one_dataset</a></code></li>
<li><code><a title="tasks.reduce.ReduceTaskCognitive.params" href="#tasks.reduce.ReduceTaskCognitive.params">params</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="tasks.reduce.ReduceTaskCognitive"><code class="flex name class">
<span>class <span class="ident">ReduceTaskCognitive</span></span>
<span>(</span><span>params: dict, batch_size: int, mode: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Class method for ReduceTask .</p>
<p>Initialize the instance .</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>dict</code></dt>
<dd>[description]</dd>
<dt><strong><code>batch_size</code></strong> :&ensp;<code>int</code></dt>
<dd>[description]</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReduceTaskCognitive:
    &#34;&#34;&#34;
    Class method for ReduceTask .
    &#34;&#34;&#34;

    def __init__(self, params: dict, batch_size: int, mode: str) -&gt; None:
        &#34;&#34;&#34;
        Initialize the instance .

        Args:
            params (dict): [description]
            batch_size (int): [description]
            mode (str): [description]
        &#34;&#34;&#34;
        self._params = params
        self._batch_size = batch_size
        self._ob_size = 0
        self._act_size = 0
        self._mode = mode

    def one_dataset(self) -&gt; Tuple[np.ndarray, np.ndarray]:
        &#34;&#34;&#34;
        Return a tuple containing one - dimensional dataset .

        Returns:
            Tuple[np.ndarray, np.ndarray]: [description]
        &#34;&#34;&#34;
        return Tuple[np.ndarray, np.ndarray]

    def dataset(self, n_trials: int = 1):
        multy_inputs, multy_outputs = self.one_dataset()
        for _ in range(n_trials - 1):
            inputs, outputs = self.one_dataset()
            multy_inputs = np.concatenate((multy_inputs, inputs), axis=0)
            multy_outputs = np.concatenate((multy_outputs, outputs), axis=0)
        return multy_inputs, multy_outputs

    @property
    def feature_and_act_size(self) -&gt; Tuple[int, int]:
        &#34;&#34;&#34;
        Returns the feature and action size .

        Returns:
            Tuple[int, int]: [feature size, act_size (output size)]
        &#34;&#34;&#34;
        return self._ob_size, self._act_size

    @feature_and_act_size.setter
    def feature_and_act_size(self, values: Tuple[int, int]):
        &#34;&#34;&#34;
        Set the feature and action size .

        Args:
            values (Tuple[int, int]): [feature size, act_size (output size)]
        &#34;&#34;&#34;
        self._ob_size, self._act_size = values

    @property
    def params(self) -&gt; dict:
        &#34;&#34;&#34;
        A dictionary with the current parameters .

        Returns:
            dict: [description]
        &#34;&#34;&#34;
        return self._params

    @params.setter
    def params(self, new_params: dict):
        &#34;&#34;&#34;
        Set the new parameters of this query.

        Args:
            new_params (dict): [description]
        &#34;&#34;&#34;
        self._params = new_params

    @property
    def batch_size(self) -&gt; int:
        &#34;&#34;&#34;
        Number of batches that have been created .

        Returns:
            int: [description]
        &#34;&#34;&#34;
        return self._batch_size

    @batch_size.setter
    def batch_size(self, new_batch_size: int):
        &#34;&#34;&#34;
        Set the batch_size of the batch .

        Args:
            new_batch_size (int): [description]
        &#34;&#34;&#34;
        self._batch_size = new_batch_size</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="tasks.reduce.CtxDMTask" href="#tasks.reduce.CtxDMTask">CtxDMTask</a></li>
<li><a title="tasks.reduce.DMTask" href="#tasks.reduce.DMTask">DMTask</a></li>
<li><a title="tasks.reduce.MultyReduceTasks" href="#tasks.reduce.MultyReduceTasks">MultyReduceTasks</a></li>
<li><a title="tasks.reduce.RomoTask" href="#tasks.reduce.RomoTask">RomoTask</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="tasks.reduce.ReduceTaskCognitive.batch_size"><code class="name">var <span class="ident">batch_size</span> : int</code></dt>
<dd>
<div class="desc"><p>Number of batches that have been created .</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def batch_size(self) -&gt; int:
    &#34;&#34;&#34;
    Number of batches that have been created .

    Returns:
        int: [description]
    &#34;&#34;&#34;
    return self._batch_size</code></pre>
</details>
</dd>
<dt id="tasks.reduce.ReduceTaskCognitive.feature_and_act_size"><code class="name">var <span class="ident">feature_and_act_size</span> : Tuple[int, int]</code></dt>
<dd>
<div class="desc"><p>Returns the feature and action size .</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[int, int]</code></dt>
<dd>[feature size, act_size (output size)]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def feature_and_act_size(self) -&gt; Tuple[int, int]:
    &#34;&#34;&#34;
    Returns the feature and action size .

    Returns:
        Tuple[int, int]: [feature size, act_size (output size)]
    &#34;&#34;&#34;
    return self._ob_size, self._act_size</code></pre>
</details>
</dd>
<dt id="tasks.reduce.ReduceTaskCognitive.params"><code class="name">var <span class="ident">params</span> : dict</code></dt>
<dd>
<div class="desc"><p>A dictionary with the current parameters .</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def params(self) -&gt; dict:
    &#34;&#34;&#34;
    A dictionary with the current parameters .

    Returns:
        dict: [description]
    &#34;&#34;&#34;
    return self._params</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tasks.reduce.ReduceTaskCognitive.dataset"><code class="name flex">
<span>def <span class="ident">dataset</span></span>(<span>self, n_trials: int = 1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dataset(self, n_trials: int = 1):
    multy_inputs, multy_outputs = self.one_dataset()
    for _ in range(n_trials - 1):
        inputs, outputs = self.one_dataset()
        multy_inputs = np.concatenate((multy_inputs, inputs), axis=0)
        multy_outputs = np.concatenate((multy_outputs, outputs), axis=0)
    return multy_inputs, multy_outputs</code></pre>
</details>
</dd>
<dt id="tasks.reduce.ReduceTaskCognitive.one_dataset"><code class="name flex">
<span>def <span class="ident">one_dataset</span></span>(<span>self) ‑> Tuple[numpy.ndarray, numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>Return a tuple containing one - dimensional dataset .</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[np.ndarray, np.ndarray]</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def one_dataset(self) -&gt; Tuple[np.ndarray, np.ndarray]:
    &#34;&#34;&#34;
    Return a tuple containing one - dimensional dataset .

    Returns:
        Tuple[np.ndarray, np.ndarray]: [description]
    &#34;&#34;&#34;
    return Tuple[np.ndarray, np.ndarray]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tasks.reduce.RomoTask"><code class="flex name class">
<span>class <span class="ident">RomoTask</span></span>
<span>(</span><span>params: Optional[dict] = None, batch_size: int = 1, mode: str = 'random')</span>
</code></dt>
<dd>
<div class="desc"><p>The challenge is for the subjects or the network to
remember the first stimulus. Then, after the delay time,
the second stimulus comes. The network must compare this
incentive and respond correctly.</p>
<p>Ref: <a href="https://www.nature.com/articles/20939">https://www.nature.com/articles/20939</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ReduceTaskCognitive</code></strong> :&ensp;<code>[type]</code></dt>
<dd>[description]</dd>
</dl>
<p>Initialize the model .</p>
<h2 id="args_1">Args</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>dict</code></dt>
<dd>[description]</dd>
<dt><strong><code>batch_size</code></strong> :&ensp;<code>int</code></dt>
<dd>[description]</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>[description]. Defaults to "random".</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RomoTask(ReduceTaskCognitive):
    &#34;&#34;&#34;
    The challenge is for the subjects or the network to
    remember the first stimulus. Then, after the delay time,
    the second stimulus comes. The network must compare this
    incentive and respond correctly.

    Ref: https://www.nature.com/articles/20939


    Args:
        ReduceTaskCognitive ([type]): [description]
    &#34;&#34;&#34;

    def __init__(
        self, params: Optional[dict] = None, batch_size: int = 1, mode: str = &#34;random&#34;
    ) -&gt; None:
        &#34;&#34;&#34;
        Initialize the model .

        Args:
            params (dict): [description]
            batch_size (int): [description]
            mode (str, optional): [description]. Defaults to &#34;random&#34;.
        &#34;&#34;&#34;
        if params is None:
            params = DefaultParams(&#34;RomoTask&#34;).generate_params()
        super().__init__(params, batch_size, mode)
        self._ob_size = 2
        self._act_size = 3

    def _one_dataset(self) -&gt; Tuple[np.ndarray, np.ndarray]:
        &#34;&#34;&#34;
        Returns a single dataset with the given size and target .

        Returns:
            Tuple[np.ndarray, np.ndarray]: [description]
        &#34;&#34;&#34;
        dt = self.params[&#34;dt&#34;]
        trial_time = int(self._params[&#34;trial_time&#34;] / dt)
        delay = int(self._params[&#34;delay&#34;] / dt)
        if self._mode == &#34;random&#34;:
            values_first = np.random.uniform(0, 1, size=(self._batch_size))
            values_second = np.random.uniform(0, 1, size=(self._batch_size))
            # TODO: добавить проверку на совпадения (хотя это маловероятно)
            inputs = np.zeros(
                (2 * (trial_time + delay), self._batch_size, self._ob_size)
            )
            inputs[: 2 * trial_time + delay, :, 0] = 1
            inputs[:trial_time, :, 1] = values_first
            inputs[trial_time + delay : -delay, :, 1] = values_second
            target_output = np.zeros(
                (2 * (trial_time + delay), self._batch_size, self._act_size)
            )
            target_output[:, :, 0] = inputs[:, :, 0]
            target_output[2 * trial_time + delay :, :, 1] = values_first &lt; values_second
            target_output[2 * trial_time + delay :, :, 2] = values_second &lt; values_first
            return inputs, target_output

    def one_dataset(self):
        &#34;&#34;&#34;
        Return a single dataset containing only one dataset .

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        return self._one_dataset()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tasks.reduce.ReduceTaskCognitive" href="#tasks.reduce.ReduceTaskCognitive">ReduceTaskCognitive</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="tasks.reduce.RomoTaskRandomMod" href="#tasks.reduce.RomoTaskRandomMod">RomoTaskRandomMod</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="tasks.reduce.RomoTask.one_dataset"><code class="name flex">
<span>def <span class="ident">one_dataset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a single dataset containing only one dataset .</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>[type]</code></dt>
<dd>[description]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def one_dataset(self):
    &#34;&#34;&#34;
    Return a single dataset containing only one dataset .

    Returns:
        [type]: [description]
    &#34;&#34;&#34;
    return self._one_dataset()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="tasks.reduce.ReduceTaskCognitive" href="#tasks.reduce.ReduceTaskCognitive">ReduceTaskCognitive</a></b></code>:
<ul class="hlist">
<li><code><a title="tasks.reduce.ReduceTaskCognitive.batch_size" href="#tasks.reduce.ReduceTaskCognitive.batch_size">batch_size</a></code></li>
<li><code><a title="tasks.reduce.ReduceTaskCognitive.feature_and_act_size" href="#tasks.reduce.ReduceTaskCognitive.feature_and_act_size">feature_and_act_size</a></code></li>
<li><code><a title="tasks.reduce.ReduceTaskCognitive.params" href="#tasks.reduce.ReduceTaskCognitive.params">params</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="tasks.reduce.RomoTask1"><code class="flex name class">
<span>class <span class="ident">RomoTask1</span></span>
<span>(</span><span>params: Optional[dict] = None, batch_size: int = 1, mode: str = 'random')</span>
</code></dt>
<dd>
<div class="desc"><p>Trial task that is used for a random mod .</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>RomoTask</code></strong> :&ensp;<code>[type]</code></dt>
<dd>[description]</dd>
</dl>
<p>Initialize the model .</p>
<h2 id="args_1">Args</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>dict</code></dt>
<dd>[description]</dd>
<dt><strong><code>batch_size</code></strong> :&ensp;<code>int</code></dt>
<dd>[description]</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>[description]. Defaults to "random".</dd>
<dt><strong><code>n_mods</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>[description]. Defaults to 1.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RomoTask1(RomoTaskRandomMod):
    def __init__(
        self, params: Optional[dict] = None, batch_size: int = 1, mode: str = &#34;random&#34;
    ) -&gt; None:

        super().__init__(params, batch_size, mode)

    def one_dataset(self, mode=0):
        return self._one_dataset_mod(mode)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tasks.reduce.RomoTaskRandomMod" href="#tasks.reduce.RomoTaskRandomMod">RomoTaskRandomMod</a></li>
<li><a title="tasks.reduce.RomoTask" href="#tasks.reduce.RomoTask">RomoTask</a></li>
<li><a title="tasks.reduce.ReduceTaskCognitive" href="#tasks.reduce.ReduceTaskCognitive">ReduceTaskCognitive</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="tasks.reduce.RomoTaskRandomMod" href="#tasks.reduce.RomoTaskRandomMod">RomoTaskRandomMod</a></b></code>:
<ul class="hlist">
<li><code><a title="tasks.reduce.RomoTaskRandomMod.batch_size" href="#tasks.reduce.ReduceTaskCognitive.batch_size">batch_size</a></code></li>
<li><code><a title="tasks.reduce.RomoTaskRandomMod.feature_and_act_size" href="#tasks.reduce.ReduceTaskCognitive.feature_and_act_size">feature_and_act_size</a></code></li>
<li><code><a title="tasks.reduce.RomoTaskRandomMod.one_dataset" href="#tasks.reduce.RomoTask.one_dataset">one_dataset</a></code></li>
<li><code><a title="tasks.reduce.RomoTaskRandomMod.params" href="#tasks.reduce.ReduceTaskCognitive.params">params</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="tasks.reduce.RomoTask2"><code class="flex name class">
<span>class <span class="ident">RomoTask2</span></span>
<span>(</span><span>params: Optional[dict] = None, batch_size: int = 1, mode: str = 'random')</span>
</code></dt>
<dd>
<div class="desc"><p>Trial task that is used for a random mod .</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>RomoTask</code></strong> :&ensp;<code>[type]</code></dt>
<dd>[description]</dd>
</dl>
<p>Initialize the model .</p>
<h2 id="args_1">Args</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>dict</code></dt>
<dd>[description]</dd>
<dt><strong><code>batch_size</code></strong> :&ensp;<code>int</code></dt>
<dd>[description]</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>[description]. Defaults to "random".</dd>
<dt><strong><code>n_mods</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>[description]. Defaults to 1.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RomoTask2(RomoTaskRandomMod):
    def __init__(
        self, params: Optional[dict] = None, batch_size: int = 1, mode: str = &#34;random&#34;
    ) -&gt; None:

        super().__init__(params, batch_size, mode)

    def one_dataset(self, mode=1):
        return self._one_dataset_mod(mode)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tasks.reduce.RomoTaskRandomMod" href="#tasks.reduce.RomoTaskRandomMod">RomoTaskRandomMod</a></li>
<li><a title="tasks.reduce.RomoTask" href="#tasks.reduce.RomoTask">RomoTask</a></li>
<li><a title="tasks.reduce.ReduceTaskCognitive" href="#tasks.reduce.ReduceTaskCognitive">ReduceTaskCognitive</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="tasks.reduce.RomoTaskRandomMod" href="#tasks.reduce.RomoTaskRandomMod">RomoTaskRandomMod</a></b></code>:
<ul class="hlist">
<li><code><a title="tasks.reduce.RomoTaskRandomMod.batch_size" href="#tasks.reduce.ReduceTaskCognitive.batch_size">batch_size</a></code></li>
<li><code><a title="tasks.reduce.RomoTaskRandomMod.feature_and_act_size" href="#tasks.reduce.ReduceTaskCognitive.feature_and_act_size">feature_and_act_size</a></code></li>
<li><code><a title="tasks.reduce.RomoTaskRandomMod.one_dataset" href="#tasks.reduce.RomoTask.one_dataset">one_dataset</a></code></li>
<li><code><a title="tasks.reduce.RomoTaskRandomMod.params" href="#tasks.reduce.ReduceTaskCognitive.params">params</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="tasks.reduce.RomoTaskRandomMod"><code class="flex name class">
<span>class <span class="ident">RomoTaskRandomMod</span></span>
<span>(</span><span>params: Optional[dict] = None, batch_size: int = 1, mode: str = 'random')</span>
</code></dt>
<dd>
<div class="desc"><p>Trial task that is used for a random mod .</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>RomoTask</code></strong> :&ensp;<code>[type]</code></dt>
<dd>[description]</dd>
</dl>
<p>Initialize the model .</p>
<h2 id="args_1">Args</h2>
<dl>
<dt><strong><code>params</code></strong> :&ensp;<code>dict</code></dt>
<dd>[description]</dd>
<dt><strong><code>batch_size</code></strong> :&ensp;<code>int</code></dt>
<dd>[description]</dd>
<dt><strong><code>mode</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>[description]. Defaults to "random".</dd>
<dt><strong><code>n_mods</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>[description]. Defaults to 1.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RomoTaskRandomMod(RomoTask):
    &#34;&#34;&#34;
    Trial task that is used for a random mod .

    Args:
        RomoTask ([type]): [description]
    &#34;&#34;&#34;

    def __init__(
        self, params: Optional[dict] = None, batch_size: int = 1, mode: str = &#34;random&#34;
    ) -&gt; None:
        &#34;&#34;&#34;
        Initialize the model .

        Args:
            params (dict): [description]
            batch_size (int): [description]
            mode (str, optional): [description]. Defaults to &#34;random&#34;.
            n_mods (int, optional): [description]. Defaults to 1.
        &#34;&#34;&#34;
        if params is None:
            params = DefaultParams(&#34;RomoTaskRandomMod&#34;).generate_params()
        super().__init__(params, batch_size, mode)
        self._n_mods = params[&#34;n_mods&#34;]
        self._ob_size += self._n_mods - 1

    def _one_dataset_mod(self, mode: int):
        &#34;&#34;&#34;
        Generate a single model .

        Returns:
            [type]: [description]
        &#34;&#34;&#34;
        temp, outputs = self._one_dataset()
        T = temp.shape[0]
        inputs = np.zeros((T, self._batch_size, self._ob_size))
        inputs[:, :, 0] = temp[:, :, 0]
        inputs[:, :, 1 + mode] = temp[:, :, 1]
        return inputs, outputs

    def one_dataset(self, mode: Optional[int] = None):
        if mode is None:
            mode = np.random.randint(0, self._n_mods)
        return self._one_dataset_mod(mode)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tasks.reduce.RomoTask" href="#tasks.reduce.RomoTask">RomoTask</a></li>
<li><a title="tasks.reduce.ReduceTaskCognitive" href="#tasks.reduce.ReduceTaskCognitive">ReduceTaskCognitive</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="tasks.reduce.RomoTask1" href="#tasks.reduce.RomoTask1">RomoTask1</a></li>
<li><a title="tasks.reduce.RomoTask2" href="#tasks.reduce.RomoTask2">RomoTask2</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="tasks.reduce.RomoTask" href="#tasks.reduce.RomoTask">RomoTask</a></b></code>:
<ul class="hlist">
<li><code><a title="tasks.reduce.RomoTask.batch_size" href="#tasks.reduce.ReduceTaskCognitive.batch_size">batch_size</a></code></li>
<li><code><a title="tasks.reduce.RomoTask.feature_and_act_size" href="#tasks.reduce.ReduceTaskCognitive.feature_and_act_size">feature_and_act_size</a></code></li>
<li><code><a title="tasks.reduce.RomoTask.one_dataset" href="#tasks.reduce.RomoTask.one_dataset">one_dataset</a></code></li>
<li><code><a title="tasks.reduce.RomoTask.params" href="#tasks.reduce.ReduceTaskCognitive.params">params</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tasks" href="index.html">tasks</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tasks.reduce.CtxDM1" href="#tasks.reduce.CtxDM1">CtxDM1</a></code></h4>
<ul class="">
<li><code><a title="tasks.reduce.CtxDM1.one_dataset" href="#tasks.reduce.CtxDM1.one_dataset">one_dataset</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tasks.reduce.CtxDM2" href="#tasks.reduce.CtxDM2">CtxDM2</a></code></h4>
<ul class="">
<li><code><a title="tasks.reduce.CtxDM2.one_dataset" href="#tasks.reduce.CtxDM2.one_dataset">one_dataset</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tasks.reduce.CtxDMTask" href="#tasks.reduce.CtxDMTask">CtxDMTask</a></code></h4>
<ul class="">
<li><code><a title="tasks.reduce.CtxDMTask.one_dataset" href="#tasks.reduce.CtxDMTask.one_dataset">one_dataset</a></code></li>
<li><code><a title="tasks.reduce.CtxDMTask.params" href="#tasks.reduce.CtxDMTask.params">params</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tasks.reduce.DMTask" href="#tasks.reduce.DMTask">DMTask</a></code></h4>
<ul class="">
<li><code><a title="tasks.reduce.DMTask.threshold" href="#tasks.reduce.DMTask.threshold">threshold</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tasks.reduce.DMTask1" href="#tasks.reduce.DMTask1">DMTask1</a></code></h4>
</li>
<li>
<h4><code><a title="tasks.reduce.DMTask2" href="#tasks.reduce.DMTask2">DMTask2</a></code></h4>
</li>
<li>
<h4><code><a title="tasks.reduce.DMTaskRandomMod" href="#tasks.reduce.DMTaskRandomMod">DMTaskRandomMod</a></code></h4>
</li>
<li>
<h4><code><a title="tasks.reduce.DefaultParams" href="#tasks.reduce.DefaultParams">DefaultParams</a></code></h4>
<ul class="">
<li><code><a title="tasks.reduce.DefaultParams.generate_params" href="#tasks.reduce.DefaultParams.generate_params">generate_params</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tasks.reduce.MultyReduceTasks" href="#tasks.reduce.MultyReduceTasks">MultyReduceTasks</a></code></h4>
<ul class="">
<li><code><a title="tasks.reduce.MultyReduceTasks.TASKSDICT" href="#tasks.reduce.MultyReduceTasks.TASKSDICT">TASKSDICT</a></code></li>
<li><code><a title="tasks.reduce.MultyReduceTasks.feature_and_act_every_task_size" href="#tasks.reduce.MultyReduceTasks.feature_and_act_every_task_size">feature_and_act_every_task_size</a></code></li>
<li><code><a title="tasks.reduce.MultyReduceTasks.feature_and_act_size" href="#tasks.reduce.MultyReduceTasks.feature_and_act_size">feature_and_act_size</a></code></li>
<li><code><a title="tasks.reduce.MultyReduceTasks.n_mods" href="#tasks.reduce.MultyReduceTasks.n_mods">n_mods</a></code></li>
<li><code><a title="tasks.reduce.MultyReduceTasks.task_list" href="#tasks.reduce.MultyReduceTasks.task_list">task_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tasks.reduce.ReduceTaskCognitive" href="#tasks.reduce.ReduceTaskCognitive">ReduceTaskCognitive</a></code></h4>
<ul class="">
<li><code><a title="tasks.reduce.ReduceTaskCognitive.batch_size" href="#tasks.reduce.ReduceTaskCognitive.batch_size">batch_size</a></code></li>
<li><code><a title="tasks.reduce.ReduceTaskCognitive.dataset" href="#tasks.reduce.ReduceTaskCognitive.dataset">dataset</a></code></li>
<li><code><a title="tasks.reduce.ReduceTaskCognitive.feature_and_act_size" href="#tasks.reduce.ReduceTaskCognitive.feature_and_act_size">feature_and_act_size</a></code></li>
<li><code><a title="tasks.reduce.ReduceTaskCognitive.one_dataset" href="#tasks.reduce.ReduceTaskCognitive.one_dataset">one_dataset</a></code></li>
<li><code><a title="tasks.reduce.ReduceTaskCognitive.params" href="#tasks.reduce.ReduceTaskCognitive.params">params</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tasks.reduce.RomoTask" href="#tasks.reduce.RomoTask">RomoTask</a></code></h4>
<ul class="">
<li><code><a title="tasks.reduce.RomoTask.one_dataset" href="#tasks.reduce.RomoTask.one_dataset">one_dataset</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tasks.reduce.RomoTask1" href="#tasks.reduce.RomoTask1">RomoTask1</a></code></h4>
</li>
<li>
<h4><code><a title="tasks.reduce.RomoTask2" href="#tasks.reduce.RomoTask2">RomoTask2</a></code></h4>
</li>
<li>
<h4><code><a title="tasks.reduce.RomoTaskRandomMod" href="#tasks.reduce.RomoTaskRandomMod">RomoTaskRandomMod</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>